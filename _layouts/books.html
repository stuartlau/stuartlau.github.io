---
layout: default
---

<link rel="stylesheet" href="/assets/css/books.css">

<div class="books-container" data-theme="light">

    {% if page.dataset %}
    {% assign dataset_str = page.dataset | append: "" %}
    {% assign book_data = site.data.books[dataset_str] %}
    {% endif %}

    {% if book_data %}
    <!-- Stats -->
    <div class="books-stats">
        <span>å…± <strong>{{ book_data | size }}</strong> æœ¬ä¹¦</span>
    </div>

    <!-- View Toggle -->
    <div class="books-controls">
        <div class="view-mode-links">
            <a href="#" class="mode-link active" data-mode="normal">å›¾ç‰‡</a>
            <span class="mode-divider">/</span>
            <a href="#" class="mode-link" data-mode="minimal">æ–‡å­—</a>
        </div>
    </div>

    <div class="books-grid" id="books-grid" data-api-base="/api/books"></div>

    <!-- Loading indicator -->
    <div class="infinite-loading" style="display: none;">
        <div class="infinite-spinner">
            <div class="spinner"></div>
            <span>åŠ è½½ä¸­...</span>
        </div>
    </div>

    <!-- End indicator -->
    <div class="infinite-end" style="display: none; text-align: center; padding: 30px; color: #999;">
        <span>â€” å·²ç»åˆ°åº•å•¦ â€”</span>
    </div>

    <!-- Empty state -->
    <div class="books-empty" id="books-empty" style="display: none;">
        <p>ğŸ“­ æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„ä¹¦ç±</p>
    </div>

    {% else %}
    <div class="books-empty">
        <p>ğŸ“­ æš‚æ— è¯»ä¹¦è®°å½•</p>
    </div>
    {% endif %}
</div>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        const grid = document.getElementById('books-grid');
        const emptyState = document.getElementById('books-empty');
        const modeLinks = document.querySelectorAll('.mode-link');

        if (!grid) return;

        const apiBase = grid.dataset.apiBase;
        const itemsPerPage = 24;
        let currentPage = 1;
        let isLoading = false;
        let hasMore = true;
        let allCards = [];
        let currentMode = 'normal';

        function renderBookCard(book) {
            const statusClass = book.status ? `status-${book.status}` : '';
            const coverHtml = book.cover
                ? `<img src="${book.cover}" alt="${book.title}" loading="lazy">`
                : `<div class="cover-placeholder"><span>ğŸ“š</span></div>`;

            const ratingHtml = book.my_rating
                ? `<div class="book-rating">${Array(5).fill(0).map((_, i) =>
                    `<span class="star ${i < book.my_rating ? 'filled' : ''}">â˜…</span>`).join('')}</div>`
                : '';

            const dateHtml = book.publish_date
                ? `<div class="book-date">${book.publish_date}</div>`
                : '';

            const tooltipHtml = `
                <div class="book-tooltip">
                    ${book.cover ? `<div class="tooltip-poster"><img src="${book.cover}" alt="${book.title}"></div>` : ''}
                    <div class="tooltip-content">
                        ${book.author ? `<p><strong>ä½œè€…ï¼š</strong>${book.author}</p>` : ''}
                        ${book.translator ? `<p><strong>è¯‘è€…ï¼š</strong>${book.translator}</p>` : ''}
                        ${book.publisher ? `<p><strong>å‡ºç‰ˆç¤¾ï¼š</strong>${book.publisher}</p>` : ''}
                        ${book.publish_date ? `<p><strong>å‡ºç‰ˆæ—¥æœŸï¼š</strong>${book.publish_date}</p>` : ''}
                        ${book.pages ? `<p><strong>é¡µæ•°ï¼š</strong>${book.pages}</p>` : ''}
                        ${book.douban_rating ? `<p><strong>è±†ç“£ï¼š</strong><span class="rating-highlight">${book.douban_rating}</span>${book.rating_count ? ` (${book.rating_count}äºº)` : ''}</p>` : ''}
                        ${book.my_comment ? `<p class="tooltip-comment">ğŸ’¬ ${book.my_comment}</p>` : ''}
                    </div>
                </div>
            `;

            return `
                <a href="${book.douban_url}" target="_blank" class="book-card ${statusClass}"
                    data-douban-rating="${book.douban_rating || 0}" data-read-date="${book.read_date || ''}"
                    data-publish-date="${book.publish_date || ''}" data-title="${book.title || ''}"
                    data-status="${book.status || 'collect'}" data-author="${book.author || ''}">
                    <div class="book-cover">${coverHtml}</div>
                    <div class="book-info">
                        <h3 class="book-title" title="${book.title}">${book.title}</h3>
                        <div class="book-author">${book.author || ''}</div>
                        <div class="book-meta">${ratingHtml}${dateHtml}</div>
                    </div>
                    ${tooltipHtml}
                </a>
            `;
        }

        async function loadBooks() {
            if (isLoading || !hasMore) return;

            isLoading = true;
            document.querySelector('.infinite-loading').style.display = 'block';

            try {
                const response = await fetch(`${apiBase}/page-${currentPage}.json`);
                if (!response.ok) throw new Error('Failed to fetch');

                const data = await response.json();

                if (data.data && data.data.length > 0) {
                    data.data.forEach(book => {
                        const cardHtml = renderBookCard(book);
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = cardHtml;
                        const card = tempDiv.firstElementChild;
                        card.style.opacity = '0';
                        card.style.transform = 'translateY(10px)';
                        grid.appendChild(card);

                        requestAnimationFrame(() => {
                            card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                            card.style.opacity = '1';
                            card.style.transform = 'translateY(0)';
                        });

                        allCards.push(card);
                    });

                    currentPage++;
                    hasMore = data.page < data.total_pages;
                } else {
                    hasMore = false;
                }

                if (!hasMore) {
                    document.querySelector('.infinite-end').style.display = 'block';
                }
            } catch (error) {
                console.error('Failed to load books:', error);
                document.querySelector('.infinite-loading span').textContent = 'åŠ è½½å¤±è´¥ï¼Œç‚¹å‡»é‡è¯•';
                document.querySelector('.infinite-loading').style.cursor = 'pointer';
                document.querySelector('.infinite-loading').onclick = loadBooks;
            } finally {
                isLoading = false;
                if (hasMore) {
                    document.querySelector('.infinite-loading').style.display = 'none';
                }
            }
        }

        function sortAndRender() {
            const sortedCards = [...allCards].sort((a, b) => {
                const dateA = a.dataset.publishDate || '';
                const dateB = b.dataset.publishDate || '';
                const yearA = dateA.match(/\d{4}/)?.[0] || '0000';
                const yearB = dateB.match(/\d{4}/)?.[0] || '0000';
                return yearB.localeCompare(yearA);
            });

            sortedCards.forEach((card, index) => {
                card.style.display = '';
                card.style.order = index;
            });

            if (emptyState) {
                emptyState.style.display = allCards.length === 0 ? 'block' : 'none';
            }
        }

        modeLinks.forEach(link => {
            link.addEventListener('click', function (e) {
                e.preventDefault();
                modeLinks.forEach(l => l.classList.remove('active'));
                this.classList.add('active');
                currentMode = this.dataset.mode;

                if (currentMode === 'minimal') {
                    grid.classList.add('minimal-mode');
                } else {
                    grid.classList.remove('minimal-mode');
                }
            });
        });

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && hasMore && !isLoading) {
                    loadBooks();
                }
            });
        }, { rootMargin: '200px' });

        const endIndicator = document.querySelector('.infinite-end');
        if (endIndicator) {
            observer.observe(endIndicator);
        }

        // Load first page
        loadBooks();
    });
</script>
